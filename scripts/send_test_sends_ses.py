from __future__ import annotations

"""
O26 — Send queued test-sends via Amazon SES.

This script:
  - Connects to the SQLite database.
  - Finds verification_results rows with test_send_status = 'requested'
    and a non-null test_send_token.
  - Sends a simple verification email via SES using a bounce+TOKEN@
    return-path constructed from TEST_SEND_* settings.
  - Calls mark_test_send_sent(...) on success to stamp test_send_status
    = 'sent' and test_send_at.

Configuration is loaded from .env via src.config:

  # AWS / SES
  AWS_REGION=us-east-2
  AWS_ACCESS_KEY_ID=YOUR_KEY_ID           # optional if using default AWS creds
  AWS_SECRET_ACCESS_KEY=YOUR_SECRET_KEY   # optional if using default AWS creds

  # Test-send config
  TEST_SEND_FROM=verify@iqverifier.xyz
  TEST_SEND_REPLY_TO=verify@iqverifier.xyz
  TEST_SEND_MAIL_FROM_DOMAIN=bounce.iqverifier.xyz
  TEST_SEND_BOUNCE_PREFIX=bounce
  TEST_SEND_SUBJECT_PREFIX=[IQVerifier Test]

Usage (PowerShell):

  .venv\\Scripts\\Activate.ps1
  python .\\scripts\\send_test_sends_ses.py `
    --db data\\dev.db `
    --max 10
"""

import argparse
import sqlite3
from pathlib import Path
from typing import Any
from urllib.parse import quote_plus

import boto3
from botocore.exceptions import BotoCoreError, ClientError

from src.config import (
    AwsSesConfig,
    TestSendEmailConfig,
    load_aws_ses_config,
    load_test_send_email_config,
)
from src.verify.test_send import mark_test_send_sent


def _ensure_db_exists(db_path: str) -> None:
    p = Path(db_path)
    if not p.exists():
        raise SystemExit(f"Database not found: {p}")


def _create_ses_client(aws_cfg: AwsSesConfig) -> Any:
    kwargs: dict[str, Any] = {"region_name": aws_cfg.region}
    if aws_cfg.access_key_id and aws_cfg.secret_access_key:
        kwargs["aws_access_key_id"] = aws_cfg.access_key_id
        kwargs["aws_secret_access_key"] = aws_cfg.secret_access_key
    return boto3.client("ses", **kwargs)


def _get_queued_test_sends(
    conn: sqlite3.Connection,
    limit: int,
) -> list[tuple[int, str, str, str | None]]:
    """
    Return a list of (verification_result_id, email, token, company_name)
    for queued test-sends.

    We treat rows with:
      - test_send_status = 'requested'
      - non-null test_send_token
    as ready to be sent.
    """
    cur = conn.execute(
        """
        SELECT vr.id, e.email, vr.test_send_token, c.name AS company_name
        FROM verification_results AS vr
        JOIN emails AS e ON e.id = vr.email_id
        JOIN companies AS c ON c.id = e.company_id
        WHERE vr.test_send_status = 'requested'
          AND vr.test_send_token IS NOT NULL
        ORDER BY vr.id
        LIMIT ?
        """,
        (limit,),
    )
    rows = cur.fetchall()
    return [
        (int(r[0]), str(r[1]), str(r[2]), str(r[3]) if r[3] is not None else None) for r in rows
    ]


def _build_return_path(email_cfg: TestSendEmailConfig, token: str) -> str:
    """
    Build the envelope sender / return-path used for bounce parsing.

    Example: bounce+vr190-XYZ@bounce.iqverifier.xyz
    """
    return f"{email_cfg.bounce_prefix}+{token}@{email_cfg.mail_from_domain}"


def _build_unsubscribe_url(email: str) -> str:
    """
    Build a simple unsubscribe URL for the contact verification notice.

    This can be wired to a real API/landing page later.
    """
    base = "https://iqverifier.xyz/unsubscribe"
    return f"{base}?email={quote_plus(email)}"


def _send_one_test_email(
    conn: sqlite3.Connection,
    ses_client: Any,
    email_cfg: TestSendEmailConfig,
    *,
    verification_result_id: int,
    email: str,
    token: str,
    company_name: str | None,
    dry_run: bool = False,
) -> bool:
    return_path = _build_return_path(email_cfg, token)

    # Human-facing fields
    subject = "Contact record check"
    company_label = company_name or "your organization"
    unsubscribe_url = _build_unsubscribe_url(email)

    body_text = (
        f"Hello,\n\n"
        f"This automated message confirms that {email} is listed as a business "
        f"contact address for {company_label}.\n\n"
        f"This notice is generated by an unmonitored email address and replies "
        f"will not be read. No action is required.\n\n"
        f"If this address should not be associated with {company_label}, you can "
        f"update your contact preferences here:\n"
        f"{unsubscribe_url}\n\n"
        f"Thank you,\n"
        f"Contact Verification\n\n"
        f"—\n"
        f"You received this message because {email} appeared as a business "
        f"contact for {company_label} in our system.\n"
    )

    if dry_run:
        print(
            f"[DRY-RUN] Would send test email to {email} "
            f"(vr_id={verification_result_id}, token={token}, "
            f"return-path={return_path})",
        )
        return False

    kwargs: dict[str, Any] = {
        "Source": email_cfg.from_address,
        "Destination": {"ToAddresses": [email]},
        "Message": {
            "Subject": {"Data": subject},
            "Body": {"Text": {"Data": body_text}},
        },
        "ReturnPath": return_path,
        # Attach the token as a SES message tag so it shows up
        # in mail.tags[...] in the SNS/SQS bounce notification.
        "Tags": [
            {
                "Name": "iq_test_token",
                "Value": token,
            }
        ],
    }
    if email_cfg.reply_to:
        # You can point this to a no-reply address; replies are not required
        # for bounce processing, which uses ReturnPath instead.
        kwargs["ReplyToAddresses"] = [email_cfg.reply_to]

    try:
        ses_client.send_email(**kwargs)
    except (BotoCoreError, ClientError, Exception) as exc:  # pragma: no cover
        # We treat SES failures as transient; the row stays 'requested' so
        # it can be retried later.
        print(
            f"ERROR: Failed to send test email to {email} "
            f"(vr_id={verification_result_id}, token={token}): {exc}",
        )
        return False

    # Only mark as sent if SES accepted the message.
    mark_test_send_sent(conn, token)
    print(
        f"Sent test email to {email} "
        f"(vr_id={verification_result_id}, token={token}, "
        f"return-path={return_path})",
    )
    return True


def main(argv: list[str] | None = None) -> int:
    parser = argparse.ArgumentParser(
        description="Send queued test-sends via Amazon SES (O26).",
    )
    parser.add_argument(
        "--db",
        required=True,
        help="Path to SQLite database, e.g. data/dev.db",
    )
    parser.add_argument(
        "--max",
        type=int,
        default=10,
        help="Maximum number of queued test-sends to send in one run.",
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Do not call SES; just print what would be sent.",
    )
    args = parser.parse_args(argv)

    _ensure_db_exists(args.db)

    try:
        aws_cfg = load_aws_ses_config()
        email_cfg = load_test_send_email_config()
    except ValueError as exc:
        # Configuration error (missing or inconsistent env vars / .env)
        raise SystemExit(f"Configuration error for SES/test-sends: {exc}") from exc

    ses_client = _create_ses_client(aws_cfg)

    conn = sqlite3.connect(args.db)
    try:
        pending = _get_queued_test_sends(conn, args.max)
        if not pending:
            print("No queued test-sends found; nothing to do.")
            return 0

        print(f"Found {len(pending)} queued test-sends.")
        sent = 0
        for verif_id, email, token, company_name in pending:
            if _send_one_test_email(
                conn,
                ses_client,
                email_cfg,
                verification_result_id=verif_id,
                email=email,
                token=token,
                company_name=company_name,
                dry_run=args.dry_run,
            ):
                sent += 1

        print(f"Completed. Successfully sent {sent} test email(s).")
        return 0
    finally:
        conn.close()


if __name__ == "__main__":  # pragma: no cover
    raise SystemExit(main())
