from __future__ import annotations

import argparse
import os
import sys
from typing import Any

from src.db import get_conn


def _apply_dsn_override(dsn: str | None) -> None:
    if not dsn:
        return
    os.environ["DATABASE_URL"] = dsn
    os.environ["PG_DSN"] = dsn


def _qi(ident: str) -> str:
    return '"' + ident.replace('"', '""') + '"'


def _exec_ddl(cur: Any, ddl: str) -> None:
    """
    Execute a multi-statement DDL string safely by splitting on ';'.
    (Some Postgres drivers disallow multi-statement execute().)
    """
    for stmt in ddl.split(";"):
        s = stmt.strip()
        if s:
            cur.execute(s)


def migrate(*, schema: str) -> None:
    # Keep original intent (create tables + indexes), but make it Postgres + tenant-safe.
    ddl = f"""
    CREATE TABLE IF NOT EXISTS {_qi(schema)}.{_qi("people")} (
      id        BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      tenant_id TEXT NOT NULL DEFAULT 'dev',
      name      TEXT
    );

    CREATE TABLE IF NOT EXISTS {_qi(schema)}.{_qi("emails")} (
      id        BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      tenant_id TEXT NOT NULL DEFAULT 'dev',
      person_id BIGINT REFERENCES {_qi(schema)}.{_qi("people")}(id) ON DELETE SET NULL,
      email     TEXT NOT NULL,
      UNIQUE(tenant_id, email)
    );

    CREATE TABLE IF NOT EXISTS {_qi(schema)}.{_qi("email_provenance")} (
      id            BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      tenant_id     TEXT NOT NULL DEFAULT 'dev',
      email_id      BIGINT NOT NULL REFERENCES {_qi(schema)}.{_qi("emails")}(id) ON DELETE CASCADE,
      source_url    TEXT NOT NULL,
      discovered_at TIMESTAMPTZ NOT NULL DEFAULT (now() AT TIME ZONE 'utc'),
      UNIQUE(tenant_id, email_id, source_url)
    );

    CREATE INDEX IF NOT EXISTS ix_emails_person_id ON {_qi(schema)}.{_qi("emails")}(person_id);
    CREATE INDEX IF NOT EXISTS ix_prov_email_id ON {_qi(schema)}.{_qi("email_provenance")}(email_id);
    """.strip()

    conn = get_conn()
    try:
        cur = conn.cursor()
        try:
            _exec_ddl(cur, ddl)
        finally:
            try:
                cur.close()
            except Exception:
                pass
        conn.commit()
        print(f"Migration complete. Ensured people/emails/email_provenance in schema={schema}")
    except Exception:
        try:
            conn.rollback()
        except Exception:
            pass
        raise
    finally:
        try:
            conn.close()
        except Exception:
            pass


def main() -> None:
    ap = argparse.ArgumentParser()
    ap.add_argument(
        "--dsn",
        "--db",
        dest="dsn",
        default=None,
        help="Postgres DSN/URL (optional; overrides DATABASE_URL for this run).",
    )
    ap.add_argument(
        "--schema",
        default=os.getenv("PGSCHEMA", "public"),
        help="Target Postgres schema (default: public, or PGSCHEMA env var).",
    )
    args = ap.parse_args()
    _apply_dsn_override(args.dsn)

    migrate(schema=args.schema)


if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"ERROR: {e}", file=sys.stderr)
        raise
