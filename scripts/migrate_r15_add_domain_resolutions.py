# scripts/migrate_r15_add_domain_resolutions.py
from __future__ import annotations

"""
R15 — DNS/MX Lookup Service: Migration (PostgreSQL)

Creates or amends the `domain_resolutions` table to support deterministic MX
resolution with caching.

Columns (exact names required by R15):
- id              BIGINT PK (identity when created by this migration)
- company_id      BIGINT
- domain          TEXT          canonical domain (lower(), NFKC)
- mx_hosts        TEXT          JSON list of MX hosts sorted by pref
- preference_map  TEXT          JSON map {mx_host: pref}
- lowest_mx       TEXT          lowest-preference host (string)
- resolved_at     TEXT          ISO8601 timestamp (UTC)
- ttl             INTEGER       TTL seconds; default 86400
- failure         TEXT          null or message

(Strongly recommended optional O06 column — added if missing)
- mx_behavior     TEXT          JSON summary

Multi-tenant safety:
- Ensures tenant_id TEXT DEFAULT 'dev' exists (non-breaking, app-layer scoped).
"""

import argparse
import os
import sys
from collections.abc import Iterable
from typing import Any

from src.db import get_conn

REQUIRED_COLUMNS: tuple[tuple[str, str, str | None], ...] = (
    # (name, type, default_sql)
    ("tenant_id", "TEXT", "'dev'"),
    ("company_id", "BIGINT", None),
    ("domain", "TEXT", None),
    ("mx_hosts", "TEXT", None),
    ("preference_map", "TEXT", None),
    ("lowest_mx", "TEXT", None),
    ("resolved_at", "TEXT", None),
    ("ttl", "INTEGER", "86400"),
    ("failure", "TEXT", None),
)

OPTIONAL_COLUMNS: tuple[tuple[str, str, str | None], ...] = (("mx_behavior", "TEXT", None),)


def _apply_dsn_override(dsn: str | None) -> None:
    if not dsn:
        return
    os.environ["DATABASE_URL"] = dsn
    os.environ["PG_DSN"] = dsn


def _qi(ident: str) -> str:
    return '"' + ident.replace('"', '""') + '"'


def table_exists(cur: Any, *, schema: str, table: str) -> bool:
    cur.execute("SELECT to_regclass(%s)", (f'"{schema}"."{table}"',))
    row = cur.fetchone()
    return row is not None and row[0] is not None


def col_exists(cur: Any, *, schema: str, table: str, col: str) -> bool:
    cur.execute(
        """
        SELECT 1
          FROM information_schema.columns
         WHERE table_schema = %s
           AND table_name = %s
           AND column_name = %s
         LIMIT 1
        """,
        (schema, table, col),
    )
    return cur.fetchone() is not None


def existing_columns(cur: Any, *, schema: str, table: str) -> Iterable[str]:
    cur.execute(
        """
        SELECT column_name
          FROM information_schema.columns
         WHERE table_schema = %s AND table_name = %s
         ORDER BY column_name
        """,
        (schema, table),
    )
    return [r[0] for r in cur.fetchall()]


def create_table(cur: Any, *, schema: str) -> None:
    cur.execute(
        f"""
        CREATE TABLE IF NOT EXISTS {_qi(schema)}.{_qi("domain_resolutions")} (
            id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            tenant_id TEXT NOT NULL DEFAULT 'dev',
            company_id BIGINT,
            domain TEXT,
            mx_hosts TEXT,
            preference_map TEXT,
            lowest_mx TEXT,
            resolved_at TEXT,
            ttl INTEGER DEFAULT 86400,
            failure TEXT
        )
        """.strip()
    )


def ensure_required_columns(cur: Any, *, schema: str) -> None:
    table = "domain_resolutions"
    fq = f"{_qi(schema)}.{_qi(table)}"
    for name, typ, default_sql in REQUIRED_COLUMNS:
        if not col_exists(cur, schema=schema, table=table, col=name):
            if default_sql is None:
                cur.execute(f"ALTER TABLE {fq} ADD COLUMN {_qi(name)} {typ}")
            else:
                cur.execute(f"ALTER TABLE {fq} ADD COLUMN {_qi(name)} {typ} DEFAULT {default_sql}")


def ensure_optional_columns(cur: Any, *, schema: str) -> None:
    table = "domain_resolutions"
    fq = f"{_qi(schema)}.{_qi(table)}"
    for name, typ, default_sql in OPTIONAL_COLUMNS:
        if not col_exists(cur, schema=schema, table=table, col=name):
            if default_sql is None:
                cur.execute(f"ALTER TABLE {fq} ADD COLUMN {_qi(name)} {typ}")
            else:
                cur.execute(f"ALTER TABLE {fq} ADD COLUMN {_qi(name)} {typ} DEFAULT {default_sql}")


def ensure_indices(cur: Any, *, schema: str) -> None:
    table = f"{_qi(schema)}.{_qi('domain_resolutions')}"
    cur.execute(
        f"CREATE INDEX IF NOT EXISTS idx_domain_resolutions_company_id ON {table}(company_id)"
    )
    cur.execute(f"CREATE INDEX IF NOT EXISTS idx_domain_resolutions_domain ON {table}(domain)")
    # If tenant_id exists, a composite lookup index is often beneficial (safe + idempotent).
    if col_exists(cur, schema=schema, table="domain_resolutions", col="tenant_id"):
        cur.execute(
            f"CREATE INDEX IF NOT EXISTS idx_domain_resolutions_tenant_domain ON {table}(tenant_id, domain)"
        )


def print_header(*, schema: str) -> None:
    print(f"Using Postgres schema: {schema}")
    print("==> Applying R15 migration: domain_resolutions schema")


def print_status(cur: Any, *, schema: str) -> None:
    exists = table_exists(cur, schema=schema, table="domain_resolutions")
    print(f"· domain_resolutions                exists: {'yes' if exists else 'no'}")
    if exists:
        cols = ", ".join(sorted(existing_columns(cur, schema=schema, table="domain_resolutions")))
        print(f"· Columns: {cols}")


def run(*, schema: str) -> None:
    conn = get_conn()
    try:
        cur = conn.cursor()
        try:
            print_header(schema=schema)
            print_status(cur, schema=schema)

            create_table(cur, schema=schema)
            ensure_required_columns(cur, schema=schema)
            ensure_optional_columns(cur, schema=schema)
            ensure_indices(cur, schema=schema)

            conn.commit()

            print("✔ R15 migration completed.")
            print_status(cur, schema=schema)
            print("✔ Indices ensured (idempotent).")
            print("✔ Schema applied (safe & repeatable).")
        finally:
            try:
                cur.close()
            except Exception:
                pass
    except Exception:
        try:
            conn.rollback()
        except Exception:
            pass
        raise
    finally:
        try:
            conn.close()
        except Exception:
            pass


def main() -> None:
    ap = argparse.ArgumentParser(
        description="R15 migration: create/ensure domain_resolutions schema (PostgreSQL)."
    )
    ap.add_argument(
        "--dsn",
        "--db",
        dest="dsn",
        default=None,
        help="Postgres DSN/URL (optional; overrides DATABASE_URL for this run).",
    )
    ap.add_argument(
        "--schema",
        default=os.getenv("PGSCHEMA", "public"),
        help="Target Postgres schema (default: public, or PGSCHEMA env var).",
    )
    args = ap.parse_args()
    _apply_dsn_override(args.dsn)

    run(schema=args.schema)


if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"ERROR: {e}", file=sys.stderr)
        raise
