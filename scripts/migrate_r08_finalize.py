# scripts/migrate_r08_finalize.py
from __future__ import annotations

import argparse
import os
import sys
from typing import Any

from src.db import get_conn


def _apply_dsn_override(dsn: str | None) -> None:
    if not dsn:
        return
    os.environ["DATABASE_URL"] = dsn
    os.environ["PG_DSN"] = dsn


def _col_exists(cur: Any, *, schema: str, table: str, col: str) -> bool:
    cur.execute(
        """
        SELECT 1
          FROM information_schema.columns
         WHERE table_schema = %s
           AND table_name = %s
           AND column_name = %s
         LIMIT 1
        """,
        (schema, table, col),
    )
    return cur.fetchone() is not None


def _table_exists(cur: Any, *, schema: str, table: str) -> bool:
    cur.execute("SELECT to_regclass(%s)", (f"{schema}.{table}",))
    row = cur.fetchone()
    return row is not None and row[0] is not None


def _index_exists(cur: Any, *, schema: str, name: str) -> bool:
    cur.execute("SELECT to_regclass(%s)", (f"{schema}.{name}",))
    row = cur.fetchone()
    return row is not None and row[0] is not None


def _add_col(cur: Any, *, schema: str, table: str, col: str, ddl: str, dry: bool) -> None:
    if _col_exists(cur, schema=schema, table=table, col=col):
        print(f"[SKIP]  {table}.{col} already exists")
        return
    sql = f'ALTER TABLE {schema}."{table}" ADD COLUMN "{col}" {ddl}'
    print(f"[APPLY] {sql}")
    if not dry:
        cur.execute(sql)


def _ensure_domain_resolutions(cur: Any, *, schema: str, dry: bool) -> None:
    """
    Create domain_resolutions audit log table for R08 decisions (idempotent).
    """
    create_sql = f"""
    CREATE TABLE IF NOT EXISTS {schema}."domain_resolutions" (
      id               BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      company_id       BIGINT NOT NULL,
      company_name     TEXT NOT NULL,
      user_hint        TEXT,          -- from ingest row (may be NULL)
      chosen_domain    TEXT,          -- punycode ascii
      method           TEXT NOT NULL, -- 'hint_validated' | 'dns_valid' | 'http_redirect' | 'fallback' | ...
      confidence       INTEGER NOT NULL,  -- 0..100
      reason           TEXT,          -- brief decision note
      resolver_version TEXT NOT NULL, -- e.g. 'r08.1'
      created_at       TIMESTAMPTZ NOT NULL DEFAULT now(),
      FOREIGN KEY(company_id) REFERENCES {schema}."companies"(id) ON DELETE CASCADE
    )
    """.strip()

    idx1_name = "idx_domain_resolutions_company_id"
    idx1_sql = f'CREATE INDEX {idx1_name} ON {schema}."domain_resolutions"(company_id)'

    print("[APPLY] create domain_resolutions (if missing)")
    if not dry:
        cur.execute(create_sql)
        if not _index_exists(cur, schema=schema, name=idx1_name):
            cur.execute(idx1_sql)


def main() -> None:
    ap = argparse.ArgumentParser(description="Finalize R08 DB pieces safely (PostgreSQL)")
    ap.add_argument(
        "--dsn",
        "--db",
        dest="dsn",
        default=None,
        help="Postgres DSN/URL (optional; overrides DATABASE_URL/PG_DSN for this run).",
    )
    ap.add_argument("--dry-run", action="store_true")
    ap.add_argument(
        "--schema",
        default=os.getenv("PGSCHEMA", "public"),
        help="Target schema (default: public, or PGSCHEMA env var).",
    )
    args = ap.parse_args()
    _apply_dsn_override(args.dsn)

    conn = get_conn()
    try:
        cur = conn.cursor()
        try:
            # You already have official_domain* columns. Keep them.
            # Add a place to store the *raw* hint from ingest if missing.
            _add_col(
                cur,
                schema=args.schema,
                table="companies",
                col="user_supplied_domain",
                ddl="TEXT",
                dry=args.dry_run,
            )

            # (Optional but handy) keep per-row resolution notes on ingest staging
            _add_col(
                cur,
                schema=args.schema,
                table="ingest_items",
                col="resolved_domain",
                ddl="TEXT",
                dry=args.dry_run,
            )
            _add_col(
                cur,
                schema=args.schema,
                table="ingest_items",
                col="resolved_domain_source",
                ddl="TEXT",
                dry=args.dry_run,
            )
            _add_col(
                cur,
                schema=args.schema,
                table="ingest_items",
                col="resolved_domain_confidence",
                ddl="INTEGER",
                dry=args.dry_run,
            )

            # Create the audit log table for R08 decisions
            _ensure_domain_resolutions(cur, schema=args.schema, dry=args.dry_run)

            # Helpful lookup index
            idx_name = "idx_companies_user_supplied_domain"
            idx_sql = f'CREATE INDEX {idx_name} ON {args.schema}."companies"(user_supplied_domain)'
            if _index_exists(cur, schema=args.schema, name=idx_name):
                print(f"[SKIP]  {idx_name} already exists")
            else:
                print(f"[APPLY] {idx_sql}")
                if not args.dry_run:
                    cur.execute(idx_sql)
        finally:
            try:
                cur.close()
            except Exception:
                pass

        if args.dry_run:
            conn.rollback()
        else:
            conn.commit()
    except Exception:
        try:
            conn.rollback()
        except Exception:
            pass
        raise
    finally:
        try:
            conn.close()
        except Exception:
            pass

    print("Done.")


if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"ERROR: {e}", file=sys.stderr)
        raise
